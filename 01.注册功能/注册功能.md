
# 1. 验证邮箱是否已被注册

后台请求的url为 `http://localhost:81/queryEmailIsExist/邮箱`。 eg: `http://localhost:81/queryEmailIsExist/12345@qq.com`。这里有2个问题
>1. 邮箱里面包含有url的保留字(差不多这个意思吧)，这些保留字不会传递到后台，所以到了后台接收到的应该是`12345`,而不是`12345@qq.com`。

>2. 解决:使用encodeURIComponent('邮箱')将邮箱里面的保留字转一下,后台就能完整的接收到了

>3. 转义后的邮箱格式差不多是这样的 12345%40.com。结尾是以.com的。这个会导致SpringBoot报错(你的项目是前后端分离)。因为SpringBoot为我们做了优化，一个请求过来，会根据请求，为我们寻找对应的view(既模板)。 现在以一个.com结尾，SpringBoot认为我们正在访问首页(个人认为，未证实),而项目是前后分离的，没有index模板，所以报错了

>4. 解决: 因为是restful风格的url,直接将请求参数提前，不放到最后，就行了 eg: `http://localhost:81/邮箱/queryEmailIsExist`


# 2. vee-validate的 confirmed bug
>1. 使用`confirmed:target`, target需要进行匹对的对象，注册中的重复密码，必须和密码一样，所以有 `confirmed:password`,但是2个密码的一样是，提示不会消失
个人认为此时`confirmed:password`中的password只是一个字符串，不是真正的password的值，所以输入的值于password无法匹配，所以才一直显示错误提示。

>2. 解决： 将写法改成这样:' v-validate="confirmed:`${password}`" ', 在vue的data里面声明一个变量password，将用户的输入密码的input，用v-model和password关联起来，然后重复密码的input里面的验证改成这样，注意此时包住password不是单引号，而是超级字符了，此时里面的password会被替代成你输入的password的值，这样就能正常的匹配了。


# 3. eMail ----> email
用post请求时，有个参数为{eMail: 你的邮箱}，后台也用一个对象`private String eMail`进行接收。但是后面报错了，原因是：后台的json转换做了改变。json转换时，会把前面几个大写的字母(我测了一下，应该是前2个)转为小写。所以，参数{eMail}，在程序里面变成了{email}，将json转为对象时，找不到email，所以没有赋值，所以eMail为空了。

>1. 解决, 用`@JsonProperty说明转json时，这个字段对应的key值为eMail`
```java

@JsonProperty("eMail")
private String eMail;

```

# 4. 请求头 
后台将生成的token，放到了http响应头里面,存放在自定义的Authorization值里面，但是前端无法获取

```java
httpResponse.setHeader("Authorization", token);
```

原因是前端，只能从响应头里面获取指定的几个key的值，自定义的前端是无法获取的，需要后台协助，解决
```java

// 定义Access-Control-Expose-Headers：Authorization 让前端可以从响应头里面获取Authorization
httpResponse.addHeader("Access-Control-Expose-Headers","Authorization");
httpResponse.setHeader("Authorization", token);

```

`注意`，前面的Authorization的开头是大写，也会出现3的问题，首字母变小写了，所以获取时需要注意
```js
	if(response.headers.authorization != null) {
		console.log(response.headers.authorization);
	}
```

