# Spring Security对跨域的处理

## 大部分情况下，直接按照下面那样的配置就行了

```java

@EnableWebMvc
@Configuration
public class HttpCrossConfig implements WebMvcConfigurer {

	@Override
	public void addCorsMappings(CorsRegistry registry) {

		//设置允许跨域的路径
		registry.addMapping("/**")
				//设置允许跨域请求的域名，也可以直接一个*,表示所有的域名都可以
				.allowedOrigins("http://localhost:8080")
				//是否允许证书 不再默认开启，https认证，cookie的使用，都需要开启这个
				.allowCredentials(true)
				//设置允许的方法
				.allowedMethods("GET", "POST", "PUT", "DELETE")
				//允许的请求头
				.allowedHeaders("Content-Type")
				//跨域允许时间, 单位毫秒
				.maxAge(5000);
	}
}

```

## 但是，如果出现了特殊情况，这样的配置还不够，还是会出现跨域
我遇到的情况时这样的：每个请求都会在的请求头上面添加一个token，作为认证，key值为Authorization。在请求头添加了自定义字段了，对上面的配置类，改一下
```java
	.allowedHeaders("Authorization", "Content-Type")
```
但是还是报跨域问题了，问题和CORS的机制有关，原因，咱们一起看看吧。




## CORS请求的分类：简单请求（simple request）和 非简单请求（not-so-simple request）

### 简单请求（simple request）：满足下面的两大条件，就是简单请求
>1. 请求方式是下面三个的其中一个
```js
	HEAD
	GET
	POST
```
>2. HTTP的头信息不超出以下几种字段
```js
	Accept
	Accept-Language
	Content-Language
	Last-Event-ID
	Content-Type:只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain(但是我在开发中将其设置为application/json;charset=utf-8，不会触发非简单请求，这个待考证)
```

### 非简单请求（not-so-simple request）：简单，凡不是简单请求，那么就是非简单请求


## 非简单请求的过程
>1. 假设我们当前的域名是 `http://www.aaa.com`，请求的服务端是 `http://www.bbb.com`, 发起的api为 `http://www.bbb.com/whoAmI`为一个非简单请求
>2. 客户端发起了api请求资源了，这时浏览器检测到这时一个非简单请求, 先不发送这个请求，而是先发送了一个OPTIONS的请求到服务器，称为"预检"请求（preflight),这个请求会去询问当前的域名是否在服务器的许可名单之中，可以使用哪些HTTP请求方式和头信息字段，只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
>3. 发送出去的OPTIONS的请求，包含以下内容
```js

Origin： 当前的域名
Access-Control-Request-Method： 将要发起的请求的方式
Access-Control-Request-Headers： 额外发送的头信息字段
...(还有一些其他字段)

```
>4. 服务器会对这个请求，做出以下响应
```js

Access-Control-Allow-Origin: 允许请求的域名
Access-Control-Allow-Methods： 服务端支持的所有请求方式(这个请求结果会被缓存一段时间，在这段时间内，非简单请求就以这个Response为参考，符合这些条件就不必再发Preflight，而是直接开始真实的请求)
Access-Control-Allow-Headers： 所有允许的自定义请求头
	...(还有一些其他字段)

```
>5. 所以，浏览器接收到4中的响应后，会对发起的api进行验证，如果都符合了条件，才会进行访问，如果不符合，报错。


## 回到我们的问题
因为我的项目里面用到了安全管理框架，并且没有对Preflight这个请求做出相应的处理, 那么这个请求会导致权限管控失败。 因为Preflight是不会携带任何额外的信息，如自定义请求头，cookie,因此Spring Security拦截器会认为你没有登录。

## 解决
在Spring Security的权限配置类，里面进行配置
```java
	@Override
    protected void configure(HttpSecurity http) throws Exception {

    		http.authorizeRequests()
    			.authorizeRequests()
    			//加上这一行，SpringSecurity对Preeflight就不会进行拦截了
    			.requestMatchers(CorsUtils::isPreFlightRequest).permitAll()
    			.anyRequest().authenticated();
    }

```
